{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Overview \u00b6 For source code, see Github repository for details. This CLI utility helps you automate and test other CLIs. Installation \u00b6 Releases can be found on this page for download: Releases Github Page Linux \u00b6 You will need the following installed: imagemagick You can then download the binary above to proceed by placing it in your PATH . MacOS \u00b6 You will need the following installed: imagemagick the python library screenshot After these are installed, ensure that screenshot has permissions for capturing your screen. You can then download the binary above to proceed by placing it in your PATH . Windows \u00b6 Currently unsupported. Basic Usage \u00b6 Warning for MacOS users : For now, you will want to set the environment variable WINDOW_NAME to whichever application name you are using to execute your commands. For example, if you use iTerm or alacritty , you will want to set your export WINDOW_NAME=iTerm or export WINDOW_NAME=alacritty for clingy to know which application to target for screenshots. See this link for details on how to structure the clingy YAML files. # MacOS - See above warning and instruction about WINDOW_NAME # creates a .clingy.yaml file clingy init # validate your clingy file and local environment clingy validate -i ./.clingy.yaml # runs against the above .clingy.yaml file and save its contents to output clingy run -i ./.clingy.yaml -o ./output # you should see an output directory with a new timestamp of an example run that looks like below: > ls ./output -al ... drwxr-xr-x 3 user users 4096 Jul 20 00 :00 . drwxr-xr-x 11 user users 4096 Jul 20 00 :00 .. drwxr-xr-x 2 user users 4096 Jul 20 00 :00 2158369886 # <---- This contains your report # clean up artifacts with clean clingy clean -o ./output Rationale \u00b6 I built this tool because I could not find comprehensive CLI/TUI automation tools out there. I found plenty of tools to automate desktop environments, but not one that helped CLI-builders and CLI-testers. I wanted a tool like this to help me view and evaluate user-flows similar to what frameworks like Cypress or NightwatchJS do for web. With the emergence of interactive frameworks for TUIs like BubbleTea or Rich , the complexity of interfaces in terminals has skyrocketed. The goal is to eventually support common actions that CLI/TUI builders and testers would want to employ in automating common tasks with development. The goals of this tool are as follows: capturing actual usage with colors in various dimensions in a terminal emulator input and output - be able to pass values from one step to another in a series of commands screenshots/records - be able to record common user flows with screenshots or screen recordings annotated reports - stitch together recordings/screenshots into a clean browsable report with annotations","title":"Overview"},{"location":"#overview","text":"For source code, see Github repository for details. This CLI utility helps you automate and test other CLIs.","title":"Overview"},{"location":"#installation","text":"Releases can be found on this page for download: Releases Github Page","title":"Installation"},{"location":"#linux","text":"You will need the following installed: imagemagick You can then download the binary above to proceed by placing it in your PATH .","title":"Linux"},{"location":"#macos","text":"You will need the following installed: imagemagick the python library screenshot After these are installed, ensure that screenshot has permissions for capturing your screen. You can then download the binary above to proceed by placing it in your PATH .","title":"MacOS"},{"location":"#windows","text":"Currently unsupported.","title":"Windows"},{"location":"#basic-usage","text":"Warning for MacOS users : For now, you will want to set the environment variable WINDOW_NAME to whichever application name you are using to execute your commands. For example, if you use iTerm or alacritty , you will want to set your export WINDOW_NAME=iTerm or export WINDOW_NAME=alacritty for clingy to know which application to target for screenshots. See this link for details on how to structure the clingy YAML files. # MacOS - See above warning and instruction about WINDOW_NAME # creates a .clingy.yaml file clingy init # validate your clingy file and local environment clingy validate -i ./.clingy.yaml # runs against the above .clingy.yaml file and save its contents to output clingy run -i ./.clingy.yaml -o ./output # you should see an output directory with a new timestamp of an example run that looks like below: > ls ./output -al ... drwxr-xr-x 3 user users 4096 Jul 20 00 :00 . drwxr-xr-x 11 user users 4096 Jul 20 00 :00 .. drwxr-xr-x 2 user users 4096 Jul 20 00 :00 2158369886 # <---- This contains your report # clean up artifacts with clean clingy clean -o ./output","title":"Basic Usage"},{"location":"#rationale","text":"I built this tool because I could not find comprehensive CLI/TUI automation tools out there. I found plenty of tools to automate desktop environments, but not one that helped CLI-builders and CLI-testers. I wanted a tool like this to help me view and evaluate user-flows similar to what frameworks like Cypress or NightwatchJS do for web. With the emergence of interactive frameworks for TUIs like BubbleTea or Rich , the complexity of interfaces in terminals has skyrocketed. The goal is to eventually support common actions that CLI/TUI builders and testers would want to employ in automating common tasks with development. The goals of this tool are as follows: capturing actual usage with colors in various dimensions in a terminal emulator input and output - be able to pass values from one step to another in a series of commands screenshots/records - be able to record common user flows with screenshots or screen recordings annotated reports - stitch together recordings/screenshots into a clean browsable report with annotations","title":"Rationale"},{"location":"01_cli/","text":"CLI Reference \u00b6 The CLI is powered by Cobra , which has some pretty standard features/naming conventions. Common Flags \u00b6 --help - on any command, you can view additional information with this flag -i or --inputFile - commands that take an inputFile will use this as a clingy YAML template. If none specified, will default to .clingy.yaml . -o or --outputPath - on any command if an output path is provided, use that instead. defaults to ./output -r or --reportStyle - on any running or report-based command, this changes the desired report output format -u or --unixTimestampDirDisabled - this will disable unix timestamp subdirectory-based work and instead save directly to the specified to the location from --outputPath (or ./output if unspecified) For debugging, you can also run in debug mode with -d or --debug and additional more verbose logs will be placed in the --outputPath with details. Commands \u00b6 Clean \u00b6 clean will empty the target output directory, usually specified by --outputPath , so you can repeatedly run with a clean destination directory, especially if you are leaving unix timestamp subdirectory-based work. Warning - using this command will clean out entire output directory. Make sure it's safe to purge! Completion \u00b6 completion will install autocompletion script for the current shell. Provided by Cobra . Help \u00b6 help prints out the same help text as --help . Provided by Cobra . Init \u00b6 init will set up a sample .clingy.yaml in the current directory. The default file is generated from this snippet . This can be overridden with a desired path at -i <PATH YOU SPECIFY . Run \u00b6 run will run a specified execution from a clingy YAML file specified by the --inputFile (or .clingy.yaml by default). This function defaults to a simple HTML report . You can change this with the --reportStyle flag. Validate \u00b6 validate will check to see if you have an environment that will support running clingy. See installation and usage instructions for details. It will also validate the --inputFile passed file or the default .clingy.yaml . Run this before running clingy to check for errors before trying to execute it. Version \u00b6 version , run this to print out the current version of clingy.","title":"CLI Reference"},{"location":"01_cli/#cli-reference","text":"The CLI is powered by Cobra , which has some pretty standard features/naming conventions.","title":"CLI Reference"},{"location":"01_cli/#common-flags","text":"--help - on any command, you can view additional information with this flag -i or --inputFile - commands that take an inputFile will use this as a clingy YAML template. If none specified, will default to .clingy.yaml . -o or --outputPath - on any command if an output path is provided, use that instead. defaults to ./output -r or --reportStyle - on any running or report-based command, this changes the desired report output format -u or --unixTimestampDirDisabled - this will disable unix timestamp subdirectory-based work and instead save directly to the specified to the location from --outputPath (or ./output if unspecified) For debugging, you can also run in debug mode with -d or --debug and additional more verbose logs will be placed in the --outputPath with details.","title":"Common Flags"},{"location":"01_cli/#commands","text":"","title":"Commands"},{"location":"01_cli/#clean","text":"clean will empty the target output directory, usually specified by --outputPath , so you can repeatedly run with a clean destination directory, especially if you are leaving unix timestamp subdirectory-based work. Warning - using this command will clean out entire output directory. Make sure it's safe to purge!","title":"Clean"},{"location":"01_cli/#completion","text":"completion will install autocompletion script for the current shell. Provided by Cobra .","title":"Completion"},{"location":"01_cli/#help","text":"help prints out the same help text as --help . Provided by Cobra .","title":"Help"},{"location":"01_cli/#init","text":"init will set up a sample .clingy.yaml in the current directory. The default file is generated from this snippet . This can be overridden with a desired path at -i <PATH YOU SPECIFY .","title":"Init"},{"location":"01_cli/#run","text":"run will run a specified execution from a clingy YAML file specified by the --inputFile (or .clingy.yaml by default). This function defaults to a simple HTML report . You can change this with the --reportStyle flag.","title":"Run"},{"location":"01_cli/#validate","text":"validate will check to see if you have an environment that will support running clingy. See installation and usage instructions for details. It will also validate the --inputFile passed file or the default .clingy.yaml . Run this before running clingy to check for errors before trying to execute it.","title":"Validate"},{"location":"01_cli/#version","text":"version , run this to print out the current version of clingy.","title":"Version"},{"location":"02_yaml/","text":"clingy YAML file \u00b6 By default, clingy init will place a .clingy.yaml file in your present working directory. Top-level Parameters \u00b6 label - a label to label the entire clingy workflow description - provide a description for the clingy workflow label : sample label description : sample description Gets set on the top level with the above, like this example . Environment variables \u00b6 If you have environment variables you wish to pass into the YAML, you can do so with the following ${ENVIRONMENT_VARIABLE} in your YAML. For example: steps : - command : <INSERT A COMMAND HERE> args : - ${ENVIRONMENT_VARIABLE_HERE} # should correctly be substituted on use There is an example in this file utilizing ${TERM} . Steps \u00b6 Command \u00b6 Specify a command to execute (ex: echo ). steps : - command : <INSERT A COMMAND HERE> ... Arguments (and Inputs) \u00b6 In an array of args , provide a set of arguments to execute against. steps : - # ... other step fields args : - <INSERT AN ARGUMENT HERE> - <INSERT ANOTHER ARGUMENT HERE> # ... keep adding arguments If you want to use an input set by an output, you can use it with $[[KEY NAME]] , where KEY NAME is a value you specify in a key in a preceding step. This is highlighted in the outputs section below . Outputs \u00b6 There are a few different ways you can capture outputs, and then, in turn, use them as inputs. For example, say you were to use echo \"Hello my name is Madhu!\" , you may want to extract the name from that echo, or echo it right back up, with the intended use of: echo \"Hello $ [[name]]!\" resulting in Hello Madhu! . This document will outline the major ways in which this is possible: Full Output - capture the entirety of the output and store it for reuse Regex - evaluate a regular expression and use the first match it encounters Positional - target a delimiter (ex: | ) and specify its index There are also some arguments and helpers that transcend all output extraction mechanics. See the The overarching structure is that any output of a command you wish to store will need to be stored in an output_processing field: steps : - # ... other step fields output_processing : key : <INSERT A KEY HERE> # a key to search on later for reuse matching_type : <CHOOSE ONE OF THE MATCHING TYPES BELOW> # a matching type for use later # ... other fields specific to matching type, depending on which you chose - # ... other step fields command : <INSERT A COMMAND HERE> args : # use the key you specified above under \"key\" - $[[KEY NAME SPECIFIED ABOVE HERE FROM <INSERT A KEY HERE>]] You can also see this in the Go code here , for the ClingyOutputProcessing struct. Full Output \u00b6 This is used when matching_type is set to full . This will fully use the output of a command and store it in a map with a corresponding key for reuse. Example \u00b6 label : \"...\" steps : - label : saving input command : echo args : - sample-input-value output_processing : key : sample_input_key matching_type : full - label : using output command : echo args : - $[[sample_input_key]] This can also be found in this test case: 02_basic_full_input_will_pass.yaml . If done properly, the effect of this would be but in staggered screenshots: # step 1 runs > echo sample-input-value sample-input-value # step 2 runs > echo $ [[ sample_input_key ]] sample-input-value Regex \u00b6 This is used when matching_type is set to regex . This matching type will evaluate an additional regex field within maching_args , evaluating a regex you provide. If found, it will assign the corresponding first match to the key for reuse. Example \u00b6 label : \"...\" steps : - label : saving input command : echo args : - \"[[sample]]-input-value\" output_processing : key : sample_input_key matching_args : regex : \\[\\[([^]]+)\\] matching_type : regex - label : using output command : echo args : - $[[sample_input_key]] This can also be found in this test case: 04_basic_regex_input_will_pass.yaml . If done properly, the effect of this would be but in staggered screenshots: # step 1 runs > echo \"[[sample]]-input-value\" [[ sample ]] -input-value # step 2 runs, pulling the value out of [[ ]] > echo $ [[ sample_input_key ]] sample Positional \u00b6 This is used when matching_type is set to positional . This matching type will evaluate: * a positional_delimiter field within matching_args , splitting a string by that delimiter * a positional_index field that requires an integer you select from the delimited string above A combination of the two will result in a value, which is then stored in a map and can be retrieved by key . Example \u00b6 label : \"...\" steps : - label : saving input command : echo args : - sample-input-value output_processing : key : sample_input_key matching_args : positional_delimiter : \"-\" positional_index : 0 # this will result in \"sample\" from above, if you used \"1\" it would be \"input\" matching_type : positional - label : using output command : echo args : - $[[sample_input_key]] This can also be found in this test case: 06_basic_positional_input_will_pass.yaml . If done properly, the effect of this would be but in staggered screenshots: # step 1 runs > echo \"sample-input-value\" sample-input-value # step 2 runs, pulling the value out of [sample, input, key] of index 0, or \"sample\" > echo $ [[ sample_input_key ]] sample Other Arguments \u00b6 Fail on no matches \u00b6 If you are anticipating these and should fail, you can use the fail_on_no_match to true . This will raise an error and interrupt execution of the suite. For example: label : \"...\" steps : - label : saving input command : echo args : - hello output_processing : key : sample_input_key matching_type : regex regex : ^bye$ # this will fail, but ^hello$ will pass! fail_on_no_match : true This will error because the regex did not find that echo statement and the suite will also exit with an error code 1.","title":"clingy YAML file"},{"location":"02_yaml/#clingy-yaml-file","text":"By default, clingy init will place a .clingy.yaml file in your present working directory.","title":"clingy YAML file"},{"location":"02_yaml/#top-level-parameters","text":"label - a label to label the entire clingy workflow description - provide a description for the clingy workflow label : sample label description : sample description Gets set on the top level with the above, like this example .","title":"Top-level Parameters"},{"location":"02_yaml/#environment-variables","text":"If you have environment variables you wish to pass into the YAML, you can do so with the following ${ENVIRONMENT_VARIABLE} in your YAML. For example: steps : - command : <INSERT A COMMAND HERE> args : - ${ENVIRONMENT_VARIABLE_HERE} # should correctly be substituted on use There is an example in this file utilizing ${TERM} .","title":"Environment variables"},{"location":"02_yaml/#steps","text":"","title":"Steps"},{"location":"02_yaml/#command","text":"Specify a command to execute (ex: echo ). steps : - command : <INSERT A COMMAND HERE> ...","title":"Command"},{"location":"02_yaml/#arguments-and-inputs","text":"In an array of args , provide a set of arguments to execute against. steps : - # ... other step fields args : - <INSERT AN ARGUMENT HERE> - <INSERT ANOTHER ARGUMENT HERE> # ... keep adding arguments If you want to use an input set by an output, you can use it with $[[KEY NAME]] , where KEY NAME is a value you specify in a key in a preceding step. This is highlighted in the outputs section below .","title":"Arguments (and Inputs)"},{"location":"02_yaml/#outputs","text":"There are a few different ways you can capture outputs, and then, in turn, use them as inputs. For example, say you were to use echo \"Hello my name is Madhu!\" , you may want to extract the name from that echo, or echo it right back up, with the intended use of: echo \"Hello $ [[name]]!\" resulting in Hello Madhu! . This document will outline the major ways in which this is possible: Full Output - capture the entirety of the output and store it for reuse Regex - evaluate a regular expression and use the first match it encounters Positional - target a delimiter (ex: | ) and specify its index There are also some arguments and helpers that transcend all output extraction mechanics. See the The overarching structure is that any output of a command you wish to store will need to be stored in an output_processing field: steps : - # ... other step fields output_processing : key : <INSERT A KEY HERE> # a key to search on later for reuse matching_type : <CHOOSE ONE OF THE MATCHING TYPES BELOW> # a matching type for use later # ... other fields specific to matching type, depending on which you chose - # ... other step fields command : <INSERT A COMMAND HERE> args : # use the key you specified above under \"key\" - $[[KEY NAME SPECIFIED ABOVE HERE FROM <INSERT A KEY HERE>]] You can also see this in the Go code here , for the ClingyOutputProcessing struct.","title":"Outputs"},{"location":"02_yaml/#full-output","text":"This is used when matching_type is set to full . This will fully use the output of a command and store it in a map with a corresponding key for reuse.","title":"Full Output"},{"location":"02_yaml/#example","text":"label : \"...\" steps : - label : saving input command : echo args : - sample-input-value output_processing : key : sample_input_key matching_type : full - label : using output command : echo args : - $[[sample_input_key]] This can also be found in this test case: 02_basic_full_input_will_pass.yaml . If done properly, the effect of this would be but in staggered screenshots: # step 1 runs > echo sample-input-value sample-input-value # step 2 runs > echo $ [[ sample_input_key ]] sample-input-value","title":"Example"},{"location":"02_yaml/#regex","text":"This is used when matching_type is set to regex . This matching type will evaluate an additional regex field within maching_args , evaluating a regex you provide. If found, it will assign the corresponding first match to the key for reuse.","title":"Regex"},{"location":"02_yaml/#example_1","text":"label : \"...\" steps : - label : saving input command : echo args : - \"[[sample]]-input-value\" output_processing : key : sample_input_key matching_args : regex : \\[\\[([^]]+)\\] matching_type : regex - label : using output command : echo args : - $[[sample_input_key]] This can also be found in this test case: 04_basic_regex_input_will_pass.yaml . If done properly, the effect of this would be but in staggered screenshots: # step 1 runs > echo \"[[sample]]-input-value\" [[ sample ]] -input-value # step 2 runs, pulling the value out of [[ ]] > echo $ [[ sample_input_key ]] sample","title":"Example"},{"location":"02_yaml/#positional","text":"This is used when matching_type is set to positional . This matching type will evaluate: * a positional_delimiter field within matching_args , splitting a string by that delimiter * a positional_index field that requires an integer you select from the delimited string above A combination of the two will result in a value, which is then stored in a map and can be retrieved by key .","title":"Positional"},{"location":"02_yaml/#example_2","text":"label : \"...\" steps : - label : saving input command : echo args : - sample-input-value output_processing : key : sample_input_key matching_args : positional_delimiter : \"-\" positional_index : 0 # this will result in \"sample\" from above, if you used \"1\" it would be \"input\" matching_type : positional - label : using output command : echo args : - $[[sample_input_key]] This can also be found in this test case: 06_basic_positional_input_will_pass.yaml . If done properly, the effect of this would be but in staggered screenshots: # step 1 runs > echo \"sample-input-value\" sample-input-value # step 2 runs, pulling the value out of [sample, input, key] of index 0, or \"sample\" > echo $ [[ sample_input_key ]] sample","title":"Example"},{"location":"02_yaml/#other-arguments","text":"","title":"Other Arguments"},{"location":"02_yaml/#fail-on-no-matches","text":"If you are anticipating these and should fail, you can use the fail_on_no_match to true . This will raise an error and interrupt execution of the suite. For example: label : \"...\" steps : - label : saving input command : echo args : - hello output_processing : key : sample_input_key matching_type : regex regex : ^bye$ # this will fail, but ^hello$ will pass! fail_on_no_match : true This will error because the regex did not find that echo statement and the suite will also exit with an error code 1.","title":"Fail on no matches"},{"location":"03_outputs/","text":"Outputs \u00b6 Clingy needs an output directory (by default it will use ./output ) to execute. This then will be used to store artifacts it generates. If passed a -d (debug flag), logs in a logs.txt will also be stored in that location. This document reviews various output formats clingy will dump to the ./output/<TIMESTAMP> path. The examples generated in this file correspond to this clingy YAML file . HTML Reports - Simple \u00b6 Example can be found at this link here . This generates a simple HTML report that includes: Label Description For each step (presented as content to scroll through): Label Image Description HTML Reports - Carousel \u00b6 Example can be found at this link here . This generates a simple HTML report that includes: Label Description For each step (presented in a slideshow): Label Image Description Images Only \u00b6 This generates a series of images with the following baked into the image: Label Description An Example is shown below. Generated image from this report","title":"Outputs"},{"location":"03_outputs/#outputs","text":"Clingy needs an output directory (by default it will use ./output ) to execute. This then will be used to store artifacts it generates. If passed a -d (debug flag), logs in a logs.txt will also be stored in that location. This document reviews various output formats clingy will dump to the ./output/<TIMESTAMP> path. The examples generated in this file correspond to this clingy YAML file .","title":"Outputs"},{"location":"03_outputs/#html-reports-simple","text":"Example can be found at this link here . This generates a simple HTML report that includes: Label Description For each step (presented as content to scroll through): Label Image Description","title":"HTML Reports - Simple"},{"location":"03_outputs/#html-reports-carousel","text":"Example can be found at this link here . This generates a simple HTML report that includes: Label Description For each step (presented in a slideshow): Label Image Description","title":"HTML Reports - Carousel"},{"location":"03_outputs/#images-only","text":"This generates a series of images with the following baked into the image: Label Description An Example is shown below. Generated image from this report","title":"Images Only"}]}